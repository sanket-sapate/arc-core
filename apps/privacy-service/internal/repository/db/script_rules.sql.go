// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: script_rules.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createScriptRule = `-- name: CreateScriptRule :one
INSERT INTO script_rules (
    id, tenant_id, purpose_id, name, script_domain, rule_type, active, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, NOW(), NOW()
)
RETURNING id, tenant_id, purpose_id, name, script_domain, rule_type, active, created_at, updated_at
`

type CreateScriptRuleParams struct {
	ID           pgtype.UUID
	TenantID     pgtype.UUID
	PurposeID    pgtype.UUID
	Name         string
	ScriptDomain string
	RuleType     string
	Active       bool
}

func (q *Queries) CreateScriptRule(ctx context.Context, arg CreateScriptRuleParams) (ScriptRule, error) {
	row := q.db.QueryRow(ctx, createScriptRule,
		arg.ID,
		arg.TenantID,
		arg.PurposeID,
		arg.Name,
		arg.ScriptDomain,
		arg.RuleType,
		arg.Active,
	)
	var i ScriptRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PurposeID,
		&i.Name,
		&i.ScriptDomain,
		&i.RuleType,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteScriptRule = `-- name: DeleteScriptRule :exec
DELETE FROM script_rules 
WHERE id = $1 AND tenant_id = $2
`

type DeleteScriptRuleParams struct {
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) DeleteScriptRule(ctx context.Context, arg DeleteScriptRuleParams) error {
	_, err := q.db.Exec(ctx, deleteScriptRule, arg.ID, arg.TenantID)
	return err
}

const getScriptRule = `-- name: GetScriptRule :one
SELECT id, tenant_id, purpose_id, name, script_domain, rule_type, active, created_at, updated_at FROM script_rules 
WHERE id = $1 AND tenant_id = $2
`

type GetScriptRuleParams struct {
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) GetScriptRule(ctx context.Context, arg GetScriptRuleParams) (ScriptRule, error) {
	row := q.db.QueryRow(ctx, getScriptRule, arg.ID, arg.TenantID)
	var i ScriptRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PurposeID,
		&i.Name,
		&i.ScriptDomain,
		&i.RuleType,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listScriptRules = `-- name: ListScriptRules :many
SELECT id, tenant_id, purpose_id, name, script_domain, rule_type, active, created_at, updated_at FROM script_rules 
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListScriptRules(ctx context.Context, tenantID pgtype.UUID) ([]ScriptRule, error) {
	rows, err := q.db.Query(ctx, listScriptRules, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScriptRule
	for rows.Next() {
		var i ScriptRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.PurposeID,
			&i.Name,
			&i.ScriptDomain,
			&i.RuleType,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScriptRule = `-- name: UpdateScriptRule :one
UPDATE script_rules
SET 
    purpose_id = COALESCE(NULLIF($1::uuid, '00000000-0000-0000-0000-000000000000'::uuid), purpose_id),
    name = COALESCE(NULLIF($2::text, ''), name),
    script_domain = COALESCE(NULLIF($3::text, ''), script_domain),
    rule_type = COALESCE(NULLIF($4::text, ''), rule_type),
    active = COALESCE(NULLIF($5::boolean, active), $5::boolean),
    updated_at = NOW()
WHERE id = $6 AND tenant_id = $7
RETURNING id, tenant_id, purpose_id, name, script_domain, rule_type, active, created_at, updated_at
`

type UpdateScriptRuleParams struct {
	PurposeID    pgtype.UUID
	Name         string
	ScriptDomain string
	RuleType     string
	Active       bool
	ID           pgtype.UUID
	TenantID     pgtype.UUID
}

func (q *Queries) UpdateScriptRule(ctx context.Context, arg UpdateScriptRuleParams) (ScriptRule, error) {
	row := q.db.QueryRow(ctx, updateScriptRule,
		arg.PurposeID,
		arg.Name,
		arg.ScriptDomain,
		arg.RuleType,
		arg.Active,
		arg.ID,
		arg.TenantID,
	)
	var i ScriptRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PurposeID,
		&i.Name,
		&i.ScriptDomain,
		&i.RuleType,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
