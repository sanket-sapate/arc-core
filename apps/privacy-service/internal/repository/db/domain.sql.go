// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// ── Purposes ─────────────────────────────────────────

const createPurpose = `INSERT INTO purposes (id, organization_id, name, description, legal_basis, active)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, name, description, legal_basis, active, created_at, updated_at`

type CreatePurposeParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Description    pgtype.Text
	LegalBasis     pgtype.Text
	Active         pgtype.Bool
}

func (q *Queries) CreatePurpose(ctx context.Context, arg CreatePurposeParams) (Purpose, error) {
	row := q.db.QueryRow(ctx, createPurpose,
		arg.ID, arg.OrganizationID, arg.Name, arg.Description, arg.LegalBasis, arg.Active)
	var i Purpose
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.LegalBasis, &i.Active, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getPurpose = `SELECT id, organization_id, name, description, legal_basis, active, created_at, updated_at
FROM purposes WHERE id = $1 AND organization_id = $2`

type GetPurposeParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetPurpose(ctx context.Context, arg GetPurposeParams) (Purpose, error) {
	row := q.db.QueryRow(ctx, getPurpose, arg.ID, arg.OrganizationID)
	var i Purpose
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.LegalBasis, &i.Active, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listPurposes = `SELECT id, organization_id, name, description, legal_basis, active, created_at, updated_at
FROM purposes WHERE organization_id = $1 ORDER BY name ASC`

func (q *Queries) ListPurposes(ctx context.Context, organizationID interface{}) ([]Purpose, error) {
	rows, err := q.db.Query(ctx, listPurposes, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []Purpose
	for pgRows.Next() {
		var i Purpose
		if err := pgRows.Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.LegalBasis, &i.Active, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updatePurpose = `UPDATE purposes
SET name=$3, description=$4, legal_basis=$5, active=$6, updated_at=NOW()
WHERE id=$1 AND organization_id=$2
RETURNING id, organization_id, name, description, legal_basis, active, created_at, updated_at`

type UpdatePurposeParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Description    pgtype.Text
	LegalBasis     pgtype.Text
	Active         pgtype.Bool
}

func (q *Queries) UpdatePurpose(ctx context.Context, arg UpdatePurposeParams) (Purpose, error) {
	row := q.db.QueryRow(ctx, updatePurpose,
		arg.ID, arg.OrganizationID, arg.Name, arg.Description, arg.LegalBasis, arg.Active)
	var i Purpose
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.LegalBasis, &i.Active, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

// ── Consent Forms ─────────────────────────────────────

const createConsentForm = `INSERT INTO consent_forms (id, organization_id, name, description, active, form_config, purposes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, organization_id, name, description, active, form_config, purposes, created_at, updated_at`

type CreateConsentFormParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Description    pgtype.Text
	Active         pgtype.Bool
	FormConfig     []byte
	Purposes       []pgtype.UUID
}

func (q *Queries) CreateConsentForm(ctx context.Context, arg CreateConsentFormParams) (ConsentForm, error) {
	row := q.db.QueryRow(ctx, createConsentForm,
		arg.ID, arg.OrganizationID, arg.Name, arg.Description, arg.Active, arg.FormConfig, arg.Purposes)
	var i ConsentForm
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.Active, &i.FormConfig, &i.Purposes, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getConsentForm = `SELECT id, organization_id, name, description, active, form_config, purposes, created_at, updated_at
FROM consent_forms WHERE id=$1 AND organization_id=$2`

type GetConsentFormParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetConsentForm(ctx context.Context, arg GetConsentFormParams) (ConsentForm, error) {
	row := q.db.QueryRow(ctx, getConsentForm, arg.ID, arg.OrganizationID)
	var i ConsentForm
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.Active, &i.FormConfig, &i.Purposes, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listConsentForms = `SELECT id, organization_id, name, description, active, form_config, purposes, created_at, updated_at
FROM consent_forms WHERE organization_id=$1 ORDER BY created_at DESC`

func (q *Queries) ListConsentForms(ctx context.Context, organizationID interface{}) ([]ConsentForm, error) {
	rows, err := q.db.Query(ctx, listConsentForms, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []ConsentForm
	for pgRows.Next() {
		var i ConsentForm
		if err := pgRows.Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.Active, &i.FormConfig, &i.Purposes, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updateConsentForm = `UPDATE consent_forms
SET name=$3, description=$4, active=$5, form_config=$6, purposes=$7, updated_at=NOW()
WHERE id=$1 AND organization_id=$2
RETURNING id, organization_id, name, description, active, form_config, purposes, created_at, updated_at`

type UpdateConsentFormParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Description    pgtype.Text
	Active         pgtype.Bool
	FormConfig     []byte
	Purposes       []pgtype.UUID
}

func (q *Queries) UpdateConsentForm(ctx context.Context, arg UpdateConsentFormParams) (ConsentForm, error) {
	row := q.db.QueryRow(ctx, updateConsentForm,
		arg.ID, arg.OrganizationID, arg.Name, arg.Description, arg.Active, arg.FormConfig, arg.Purposes)
	var i ConsentForm
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Description, &i.Active, &i.FormConfig, &i.Purposes, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

// ── DPIAs ─────────────────────────────────────────────

const createDPIA = `INSERT INTO dpias (id, organization_id, name, vendor_id, status, risk_level, form_data)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, organization_id, name, vendor_id, status, risk_level, form_data, created_at, updated_at`

type CreateDPIAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	VendorID       pgtype.UUID
	Status         pgtype.Text
	RiskLevel      pgtype.Text
	FormData       []byte
}

func (q *Queries) CreateDPIA(ctx context.Context, arg CreateDPIAParams) (Dpia, error) {
	row := q.db.QueryRow(ctx, createDPIA,
		arg.ID, arg.OrganizationID, arg.Name, arg.VendorID, arg.Status, arg.RiskLevel, arg.FormData)
	var i Dpia
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.VendorID, &i.Status, &i.RiskLevel, &i.FormData, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getDPIA = `SELECT id, organization_id, name, vendor_id, status, risk_level, form_data, created_at, updated_at
FROM dpias WHERE id=$1 AND organization_id=$2`

type GetDPIAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetDPIA(ctx context.Context, arg GetDPIAParams) (Dpia, error) {
	row := q.db.QueryRow(ctx, getDPIA, arg.ID, arg.OrganizationID)
	var i Dpia
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.VendorID, &i.Status, &i.RiskLevel, &i.FormData, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listDPIAs = `SELECT id, organization_id, name, vendor_id, status, risk_level, form_data, created_at, updated_at
FROM dpias WHERE organization_id=$1 ORDER BY created_at DESC`

func (q *Queries) ListDPIAs(ctx context.Context, organizationID interface{}) ([]Dpia, error) {
	rows, err := q.db.Query(ctx, listDPIAs, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []Dpia
	for pgRows.Next() {
		var i Dpia
		if err := pgRows.Scan(&i.ID, &i.OrganizationID, &i.Name, &i.VendorID, &i.Status, &i.RiskLevel, &i.FormData, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updateDPIA = `UPDATE dpias
SET name=$3, vendor_id=$4, status=$5, risk_level=$6, form_data=$7, updated_at=NOW()
WHERE id=$1 AND organization_id=$2
RETURNING id, organization_id, name, vendor_id, status, risk_level, form_data, created_at, updated_at`

type UpdateDPIAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	VendorID       pgtype.UUID
	Status         pgtype.Text
	RiskLevel      pgtype.Text
	FormData       []byte
}

func (q *Queries) UpdateDPIA(ctx context.Context, arg UpdateDPIAParams) (Dpia, error) {
	row := q.db.QueryRow(ctx, updateDPIA,
		arg.ID, arg.OrganizationID, arg.Name, arg.VendorID, arg.Status, arg.RiskLevel, arg.FormData)
	var i Dpia
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.VendorID, &i.Status, &i.RiskLevel, &i.FormData, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

// ── ROPAs ─────────────────────────────────────────────

const createROPA = `INSERT INTO ropas (id, organization_id, name, processing_activity, legal_basis, data_categories, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, organization_id, name, processing_activity, legal_basis, data_categories, status, created_at, updated_at`

type CreateROPAParams struct {
	ID                 pgtype.UUID
	OrganizationID     pgtype.UUID
	Name               string
	ProcessingActivity pgtype.Text
	LegalBasis         pgtype.Text
	DataCategories     []string
	Status             pgtype.Text
}

func (q *Queries) CreateROPA(ctx context.Context, arg CreateROPAParams) (Ropa, error) {
	row := q.db.QueryRow(ctx, createROPA,
		arg.ID, arg.OrganizationID, arg.Name, arg.ProcessingActivity, arg.LegalBasis, arg.DataCategories, arg.Status)
	var i Ropa
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.ProcessingActivity, &i.LegalBasis, &i.DataCategories, &i.Status, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getROPA = `SELECT id, organization_id, name, processing_activity, legal_basis, data_categories, status, created_at, updated_at
FROM ropas WHERE id=$1 AND organization_id=$2`

type GetROPAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetROPA(ctx context.Context, arg GetROPAParams) (Ropa, error) {
	row := q.db.QueryRow(ctx, getROPA, arg.ID, arg.OrganizationID)
	var i Ropa
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.ProcessingActivity, &i.LegalBasis, &i.DataCategories, &i.Status, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listROPAs = `SELECT id, organization_id, name, processing_activity, legal_basis, data_categories, status, created_at, updated_at
FROM ropas WHERE organization_id=$1 ORDER BY created_at DESC`

func (q *Queries) ListROPAs(ctx context.Context, organizationID interface{}) ([]Ropa, error) {
	rows, err := q.db.Query(ctx, listROPAs, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []Ropa
	for pgRows.Next() {
		var i Ropa
		if err := pgRows.Scan(&i.ID, &i.OrganizationID, &i.Name, &i.ProcessingActivity, &i.LegalBasis, &i.DataCategories, &i.Status, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updateROPA = `UPDATE ropas
SET name=$3, processing_activity=$4, legal_basis=$5, data_categories=$6, status=$7, updated_at=NOW()
WHERE id=$1 AND organization_id=$2
RETURNING id, organization_id, name, processing_activity, legal_basis, data_categories, status, created_at, updated_at`

type UpdateROPAParams struct {
	ID                 pgtype.UUID
	OrganizationID     pgtype.UUID
	Name               string
	ProcessingActivity pgtype.Text
	LegalBasis         pgtype.Text
	DataCategories     []string
	Status             pgtype.Text
}

func (q *Queries) UpdateROPA(ctx context.Context, arg UpdateROPAParams) (Ropa, error) {
	row := q.db.QueryRow(ctx, updateROPA,
		arg.ID, arg.OrganizationID, arg.Name, arg.ProcessingActivity, arg.LegalBasis, arg.DataCategories, arg.Status)
	var i Ropa
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.ProcessingActivity, &i.LegalBasis, &i.DataCategories, &i.Status, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

// ── Privacy Requests ──────────────────────────────────

const createPrivacyRequest = `INSERT INTO privacy_requests (id, organization_id, type, status, requester_email, requester_name, description)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, organization_id, type, status, requester_email, requester_name, description, resolution, created_at, updated_at`

type CreatePrivacyRequestParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Type           string
	Status         pgtype.Text
	RequesterEmail pgtype.Text
	RequesterName  pgtype.Text
	Description    pgtype.Text
}

func (q *Queries) CreatePrivacyRequest(ctx context.Context, arg CreatePrivacyRequestParams) (PrivacyRequest, error) {
	row := q.db.QueryRow(ctx, createPrivacyRequest,
		arg.ID, arg.OrganizationID, arg.Type, arg.Status, arg.RequesterEmail, arg.RequesterName, arg.Description)
	var i PrivacyRequest
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Type, &i.Status, &i.RequesterEmail, &i.RequesterName, &i.Description, &i.Resolution, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getPrivacyRequest = `SELECT id, organization_id, type, status, requester_email, requester_name, description, resolution, created_at, updated_at
FROM privacy_requests WHERE id=$1 AND organization_id=$2`

type GetPrivacyRequestParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetPrivacyRequest(ctx context.Context, arg GetPrivacyRequestParams) (PrivacyRequest, error) {
	row := q.db.QueryRow(ctx, getPrivacyRequest, arg.ID, arg.OrganizationID)
	var i PrivacyRequest
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Type, &i.Status, &i.RequesterEmail, &i.RequesterName, &i.Description, &i.Resolution, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listPrivacyRequests = `SELECT id, organization_id, type, status, requester_email, requester_name, description, resolution, created_at, updated_at
FROM privacy_requests WHERE organization_id=$1 ORDER BY created_at DESC`

func (q *Queries) ListPrivacyRequests(ctx context.Context, organizationID interface{}) ([]PrivacyRequest, error) {
	rows, err := q.db.Query(ctx, listPrivacyRequests, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []PrivacyRequest
	for pgRows.Next() {
		var i PrivacyRequest
		if err := pgRows.Scan(&i.ID, &i.OrganizationID, &i.Type, &i.Status, &i.RequesterEmail, &i.RequesterName, &i.Description, &i.Resolution, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updatePrivacyRequest = `UPDATE privacy_requests
SET status=$3, resolution=$4, updated_at=NOW()
WHERE id=$1 AND organization_id=$2
RETURNING id, organization_id, type, status, requester_email, requester_name, description, resolution, created_at, updated_at`

type UpdatePrivacyRequestParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Status         pgtype.Text
	Resolution     pgtype.Text
}

func (q *Queries) UpdatePrivacyRequest(ctx context.Context, arg UpdatePrivacyRequestParams) (PrivacyRequest, error) {
	row := q.db.QueryRow(ctx, updatePrivacyRequest, arg.ID, arg.OrganizationID, arg.Status, arg.Resolution)
	var i PrivacyRequest
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Type, &i.Status, &i.RequesterEmail, &i.RequesterName, &i.Description, &i.Resolution, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

// ── Outbox ────────────────────────────────────────────

const insertOutboxEvent = `INSERT INTO outbox_events (id, organization_id, aggregate_type, aggregate_id, event_type, payload)
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (id) DO NOTHING`

type InsertOutboxEventParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	AggregateType  string
	AggregateID    string
	EventType      string
	Payload        []byte
}

func (q *Queries) InsertOutboxEvent(ctx context.Context, arg InsertOutboxEventParams) error {
	_, err := q.db.Exec(ctx, insertOutboxEvent,
		arg.ID, arg.OrganizationID, arg.AggregateType, arg.AggregateID, arg.EventType, arg.Payload)
	return err
}
