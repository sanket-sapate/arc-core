// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// ── Vendors ───────────────────────────────────────────────────────────────

const createVendor = `INSERT INTO vendors (id, organization_id, name, contact_email, compliance_status, risk_level)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at`

type CreateVendorParams struct {
	ID               pgtype.UUID
	OrganizationID   pgtype.UUID
	Name             string
	ContactEmail     pgtype.Text
	ComplianceStatus pgtype.Text
	RiskLevel        pgtype.Text
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (Vendor, error) {
	row := q.db.QueryRow(ctx, createVendor,
		arg.ID, arg.OrganizationID, arg.Name, arg.ContactEmail, arg.ComplianceStatus, arg.RiskLevel)
	var i Vendor
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.Name, &i.ContactEmail, &i.ComplianceStatus, &i.RiskLevel,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const getVendor = `SELECT id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at
FROM vendors WHERE id = $1 AND organization_id = $2`

type GetVendorParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetVendor(ctx context.Context, arg GetVendorParams) (Vendor, error) {
	row := q.db.QueryRow(ctx, getVendor, arg.ID, arg.OrganizationID)
	var i Vendor
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.Name, &i.ContactEmail, &i.ComplianceStatus, &i.RiskLevel,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const listVendors = `SELECT id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at
FROM vendors WHERE organization_id = $1 ORDER BY name ASC`

func (q *Queries) ListVendors(ctx context.Context, organizationID pgtype.UUID) ([]Vendor, error) {
	rows, err := q.db.Query(ctx, listVendors, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []Vendor
	for pgRows.Next() {
		var i Vendor
		if err := pgRows.Scan(
			&i.ID, &i.OrganizationID, &i.Name, &i.ContactEmail, &i.ComplianceStatus, &i.RiskLevel,
			&i.CreatedAt, &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updateVendor = `UPDATE vendors
SET name = $3, contact_email = $4, compliance_status = $5, risk_level = $6, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at`

type UpdateVendorParams struct {
	ID               pgtype.UUID
	OrganizationID   pgtype.UUID
	Name             string
	ContactEmail     pgtype.Text
	ComplianceStatus pgtype.Text
	RiskLevel        pgtype.Text
}

func (q *Queries) UpdateVendor(ctx context.Context, arg UpdateVendorParams) (Vendor, error) {
	row := q.db.QueryRow(ctx, updateVendor,
		arg.ID, arg.OrganizationID, arg.Name, arg.ContactEmail, arg.ComplianceStatus, arg.RiskLevel)
	var i Vendor
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.Name, &i.ContactEmail, &i.ComplianceStatus, &i.RiskLevel,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const deleteVendor = `DELETE FROM vendors WHERE id = $1 AND organization_id = $2`

type DeleteVendorParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) DeleteVendor(ctx context.Context, arg DeleteVendorParams) error {
	_, err := q.db.Exec(ctx, deleteVendor, arg.ID, arg.OrganizationID)
	return err
}

// ── Frameworks ────────────────────────────────────────────────────────────

const createFramework = `INSERT INTO frameworks (id, organization_id, name, version)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, name, version, created_at`

type CreateFrameworkParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Version        string
}

func (q *Queries) CreateFramework(ctx context.Context, arg CreateFrameworkParams) (Framework, error) {
	row := q.db.QueryRow(ctx, createFramework, arg.ID, arg.OrganizationID, arg.Name, arg.Version)
	var i Framework
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Version, &i.CreatedAt)
	return i, err
}

const getFramework = `SELECT id, organization_id, name, version, created_at
FROM frameworks WHERE id = $1 AND organization_id = $2`

type GetFrameworkParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetFramework(ctx context.Context, arg GetFrameworkParams) (Framework, error) {
	row := q.db.QueryRow(ctx, getFramework, arg.ID, arg.OrganizationID)
	var i Framework
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Version, &i.CreatedAt)
	return i, err
}

const listFrameworks = `SELECT id, organization_id, name, version, created_at
FROM frameworks WHERE organization_id = $1 ORDER BY name ASC`

func (q *Queries) ListFrameworks(ctx context.Context, organizationID pgtype.UUID) ([]Framework, error) {
	rows, err := q.db.Query(ctx, listFrameworks, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []Framework
	for pgRows.Next() {
		var i Framework
		if err := pgRows.Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

// ── Assessments ───────────────────────────────────────────────────────────

const createAssessment = `INSERT INTO assessments (id, organization_id, vendor_id, framework_id, status, score)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at`

type CreateAssessmentParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	VendorID       pgtype.UUID
	FrameworkID    pgtype.UUID
	Status         pgtype.Text
	Score          pgtype.Int4
}

func (q *Queries) CreateAssessment(ctx context.Context, arg CreateAssessmentParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, createAssessment,
		arg.ID, arg.OrganizationID, arg.VendorID, arg.FrameworkID, arg.Status, arg.Score)
	var i Assessment
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.VendorID, &i.FrameworkID, &i.Status, &i.Score,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const getAssessment = `SELECT id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at
FROM assessments WHERE id = $1 AND organization_id = $2`

type GetAssessmentParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetAssessment(ctx context.Context, arg GetAssessmentParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, getAssessment, arg.ID, arg.OrganizationID)
	var i Assessment
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.VendorID, &i.FrameworkID, &i.Status, &i.Score,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const listAssessmentsByVendor = `SELECT id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at
FROM assessments WHERE vendor_id = $1 AND organization_id = $2 ORDER BY created_at DESC`

type ListAssessmentsByVendorParams struct {
	VendorID       pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) ListAssessmentsByVendor(ctx context.Context, arg ListAssessmentsByVendorParams) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessmentsByVendor, arg.VendorID, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []Assessment
	for pgRows.Next() {
		var i Assessment
		if err := pgRows.Scan(
			&i.ID, &i.OrganizationID, &i.VendorID, &i.FrameworkID, &i.Status, &i.Score,
			&i.CreatedAt, &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updateAssessmentStatus = `UPDATE assessments
SET status = $3, score = $4, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at`

type UpdateAssessmentStatusParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Status         pgtype.Text
	Score          pgtype.Int4
}

func (q *Queries) UpdateAssessmentStatus(ctx context.Context, arg UpdateAssessmentStatusParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, updateAssessmentStatus, arg.ID, arg.OrganizationID, arg.Status, arg.Score)
	var i Assessment
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.VendorID, &i.FrameworkID, &i.Status, &i.Score,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

// ── DPAs ──────────────────────────────────────────────────────────────────

const createDPA = `INSERT INTO dpas (id, organization_id, vendor_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, vendor_id, status, signed_at, created_at, updated_at`

type CreateDPAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	VendorID       pgtype.UUID
	Status         string
}

func (q *Queries) CreateDPA(ctx context.Context, arg CreateDPAParams) (Dpa, error) {
	row := q.db.QueryRow(ctx, createDPA, arg.ID, arg.OrganizationID, arg.VendorID, arg.Status)
	var i Dpa
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.VendorID, &i.Status, &i.SignedAt, &i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const getDPA = `SELECT id, organization_id, vendor_id, status, signed_at, created_at, updated_at
FROM dpas WHERE id = $1 AND organization_id = $2`

type GetDPAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetDPA(ctx context.Context, arg GetDPAParams) (Dpa, error) {
	row := q.db.QueryRow(ctx, getDPA, arg.ID, arg.OrganizationID)
	var i Dpa
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.VendorID, &i.Status, &i.SignedAt, &i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const listDPAsByVendor = `SELECT id, organization_id, vendor_id, status, signed_at, created_at, updated_at
FROM dpas WHERE vendor_id = $1 AND organization_id = $2 ORDER BY created_at DESC`

type ListDPAsByVendorParams struct {
	VendorID       pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) ListDPAsByVendor(ctx context.Context, arg ListDPAsByVendorParams) ([]Dpa, error) {
	rows, err := q.db.Query(ctx, listDPAsByVendor, arg.VendorID, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []Dpa
	for pgRows.Next() {
		var i Dpa
		if err := pgRows.Scan(
			&i.ID, &i.OrganizationID, &i.VendorID, &i.Status, &i.SignedAt, &i.CreatedAt, &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

const updateDPAStatus = `UPDATE dpas
SET status = $3, signed_at = $4, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vendor_id, status, signed_at, created_at, updated_at`

type UpdateDPAStatusParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Status         string
	SignedAt       pgtype.Timestamptz
}

func (q *Queries) UpdateDPAStatus(ctx context.Context, arg UpdateDPAStatusParams) (Dpa, error) {
	row := q.db.QueryRow(ctx, updateDPAStatus, arg.ID, arg.OrganizationID, arg.Status, arg.SignedAt)
	var i Dpa
	err := row.(pgx.Row).Scan(
		&i.ID, &i.OrganizationID, &i.VendorID, &i.Status, &i.SignedAt, &i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const addDPADataScope = `INSERT INTO dpa_data_scope (dpa_id, dictionary_id, justification)
VALUES ($1, $2, $3)
ON CONFLICT (dpa_id, dictionary_id) DO UPDATE SET justification = EXCLUDED.justification`

type AddDPADataScopeParams struct {
	DpaID        pgtype.UUID
	DictionaryID pgtype.UUID
	Justification pgtype.Text
}

func (q *Queries) AddDPADataScope(ctx context.Context, arg AddDPADataScopeParams) error {
	_, err := q.db.Exec(ctx, addDPADataScope, arg.DpaID, arg.DictionaryID, arg.Justification)
	return err
}

const listDPADataScope = `SELECT d.dpa_id, d.dictionary_id, d.justification, r.name AS dict_name, r.sensitivity
FROM dpa_data_scope d
JOIN replicated_data_dictionary r ON r.id = d.dictionary_id
WHERE d.dpa_id = $1`

func (q *Queries) ListDPADataScope(ctx context.Context, dpaID pgtype.UUID) ([]DpaDataScopeRow, error) {
	rows, err := q.db.Query(ctx, listDPADataScope, dpaID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []DpaDataScopeRow
	for pgRows.Next() {
		var i DpaDataScopeRow
		if err := pgRows.Scan(&i.DpaID, &i.DictionaryID, &i.Justification, &i.DictName, &i.Sensitivity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

// ── Replicated Data Dictionary ────────────────────────────────────────────

const upsertReplicatedDictionary = `INSERT INTO replicated_data_dictionary (id, organization_id, name, sensitivity, active, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name,
    sensitivity = EXCLUDED.sensitivity,
    active = EXCLUDED.active,
    updated_at = EXCLUDED.updated_at`

type UpsertReplicatedDictionaryParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Sensitivity    string
	Active         bool
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) UpsertReplicatedDictionary(ctx context.Context, arg UpsertReplicatedDictionaryParams) error {
	_, err := q.db.Exec(ctx, upsertReplicatedDictionary,
		arg.ID, arg.OrganizationID, arg.Name, arg.Sensitivity, arg.Active, arg.UpdatedAt)
	return err
}

const deleteReplicatedDictionary = `DELETE FROM replicated_data_dictionary WHERE id = $1`

func (q *Queries) DeleteReplicatedDictionary(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteReplicatedDictionary, id)
	return err
}

const getReplicatedDictionaryItem = `SELECT id, organization_id, name, sensitivity, active, updated_at
FROM replicated_data_dictionary WHERE id = $1`

func (q *Queries) GetReplicatedDictionaryItem(ctx context.Context, id pgtype.UUID) (ReplicatedDataDictionary, error) {
	row := q.db.QueryRow(ctx, getReplicatedDictionaryItem, id)
	var i ReplicatedDataDictionary
	err := row.(pgx.Row).Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Sensitivity, &i.Active, &i.UpdatedAt)
	return i, err
}

const listReplicatedDictionary = `SELECT id, organization_id, name, sensitivity, active, updated_at
FROM replicated_data_dictionary WHERE organization_id = $1 AND active = true ORDER BY name ASC`

func (q *Queries) ListReplicatedDictionary(ctx context.Context, organizationID pgtype.UUID) ([]ReplicatedDataDictionary, error) {
	rows, err := q.db.Query(ctx, listReplicatedDictionary, organizationID)
	if err != nil {
		return nil, err
	}
	pgRows := rows.(pgx.Rows)
	defer pgRows.Close()
	var items []ReplicatedDataDictionary
	for pgRows.Next() {
		var i ReplicatedDataDictionary
		if err := pgRows.Scan(&i.ID, &i.OrganizationID, &i.Name, &i.Sensitivity, &i.Active, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	return items, pgRows.Err()
}

// ── Outbox ────────────────────────────────────────────────────────────────

const insertOutboxEvent = `INSERT INTO outbox_events (id, organization_id, aggregate_type, aggregate_id, event_type, payload)
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (id) DO NOTHING`

type InsertOutboxEventParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	AggregateType  string
	AggregateID    string
	EventType      string
	Payload        []byte
}

func (q *Queries) InsertOutboxEvent(ctx context.Context, arg InsertOutboxEventParams) error {
	_, err := q.db.Exec(ctx, insertOutboxEvent,
		arg.ID, arg.OrganizationID, arg.AggregateType, arg.AggregateID, arg.EventType, arg.Payload)
	return err
}
