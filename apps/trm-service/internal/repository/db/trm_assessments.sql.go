// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trm_assessments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuditCycle = `-- name: CreateAuditCycle :one

INSERT INTO audit_cycles (id, organization_id, name, status, start_date, end_date)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, name, status, start_date, end_date, created_at, updated_at
`

type CreateAuditCycleParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Status         pgtype.Text
	StartDate      pgtype.Timestamptz
	EndDate        pgtype.Timestamptz
}

// ── Audit Cycles ──────────────────────────────────────────────────────────
func (q *Queries) CreateAuditCycle(ctx context.Context, arg CreateAuditCycleParams) (AuditCycle, error) {
	row := q.db.QueryRow(ctx, createAuditCycle,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var i AuditCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFrameworkQuestion = `-- name: CreateFrameworkQuestion :one

INSERT INTO framework_questions (id, framework_id, question_text, question_type, options)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, framework_id, question_text, question_type, options, created_at, updated_at
`

type CreateFrameworkQuestionParams struct {
	ID           pgtype.UUID
	FrameworkID  pgtype.UUID
	QuestionText string
	QuestionType pgtype.Text
	Options      []byte
}

// ── Framework Questions ───────────────────────────────────────────────────
func (q *Queries) CreateFrameworkQuestion(ctx context.Context, arg CreateFrameworkQuestionParams) (FrameworkQuestion, error) {
	row := q.db.QueryRow(ctx, createFrameworkQuestion,
		arg.ID,
		arg.FrameworkID,
		arg.QuestionText,
		arg.QuestionType,
		arg.Options,
	)
	var i FrameworkQuestion
	err := row.Scan(
		&i.ID,
		&i.FrameworkID,
		&i.QuestionText,
		&i.QuestionType,
		&i.Options,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAuditCycle = `-- name: DeleteAuditCycle :exec
DELETE FROM audit_cycles
WHERE id = $1 AND organization_id = $2
`

type DeleteAuditCycleParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) DeleteAuditCycle(ctx context.Context, arg DeleteAuditCycleParams) error {
	_, err := q.db.Exec(ctx, deleteAuditCycle, arg.ID, arg.OrganizationID)
	return err
}

const deleteFramework = `-- name: DeleteFramework :exec
DELETE FROM frameworks
WHERE id = $1 AND organization_id = $2
`

type DeleteFrameworkParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) DeleteFramework(ctx context.Context, arg DeleteFrameworkParams) error {
	_, err := q.db.Exec(ctx, deleteFramework, arg.ID, arg.OrganizationID)
	return err
}

const getAuditCycle = `-- name: GetAuditCycle :one
SELECT id, organization_id, name, status, start_date, end_date, created_at, updated_at FROM audit_cycles
WHERE id = $1 AND organization_id = $2
`

type GetAuditCycleParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetAuditCycle(ctx context.Context, arg GetAuditCycleParams) (AuditCycle, error) {
	row := q.db.QueryRow(ctx, getAuditCycle, arg.ID, arg.OrganizationID)
	var i AuditCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAssessmentAnswers = `-- name: ListAssessmentAnswers :many
SELECT id, assessment_id, question_id, answer_text, answer_options, created_at, updated_at FROM assessment_answers
WHERE assessment_id = $1
`

func (q *Queries) ListAssessmentAnswers(ctx context.Context, assessmentID pgtype.UUID) ([]AssessmentAnswer, error) {
	rows, err := q.db.Query(ctx, listAssessmentAnswers, assessmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssessmentAnswer
	for rows.Next() {
		var i AssessmentAnswer
		if err := rows.Scan(
			&i.ID,
			&i.AssessmentID,
			&i.QuestionID,
			&i.AnswerText,
			&i.AnswerOptions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditCycles = `-- name: ListAuditCycles :many
SELECT id, organization_id, name, status, start_date, end_date, created_at, updated_at FROM audit_cycles
WHERE organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAuditCycles(ctx context.Context, organizationID pgtype.UUID) ([]AuditCycle, error) {
	rows, err := q.db.Query(ctx, listAuditCycles, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditCycle
	for rows.Next() {
		var i AuditCycle
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFrameworkQuestions = `-- name: ListFrameworkQuestions :many
SELECT id, framework_id, question_text, question_type, options, created_at, updated_at FROM framework_questions
WHERE framework_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListFrameworkQuestions(ctx context.Context, frameworkID pgtype.UUID) ([]FrameworkQuestion, error) {
	rows, err := q.db.Query(ctx, listFrameworkQuestions, frameworkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FrameworkQuestion
	for rows.Next() {
		var i FrameworkQuestion
		if err := rows.Scan(
			&i.ID,
			&i.FrameworkID,
			&i.QuestionText,
			&i.QuestionType,
			&i.Options,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssessmentCycle = `-- name: UpdateAssessmentCycle :one

UPDATE assessments
SET audit_cycle_id = $3, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at, audit_cycle_id
`

type UpdateAssessmentCycleParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	AuditCycleID   pgtype.UUID
}

// ── Enhanced Assessments ──────────────────────────────────────────────────
func (q *Queries) UpdateAssessmentCycle(ctx context.Context, arg UpdateAssessmentCycleParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, updateAssessmentCycle, arg.ID, arg.OrganizationID, arg.AuditCycleID)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VendorID,
		&i.FrameworkID,
		&i.Status,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuditCycleID,
	)
	return i, err
}

const updateAuditCycle = `-- name: UpdateAuditCycle :one
UPDATE audit_cycles
SET name = $3, status = $4, start_date = $5, end_date = $6, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, name, status, start_date, end_date, created_at, updated_at
`

type UpdateAuditCycleParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Status         pgtype.Text
	StartDate      pgtype.Timestamptz
	EndDate        pgtype.Timestamptz
}

func (q *Queries) UpdateAuditCycle(ctx context.Context, arg UpdateAuditCycleParams) (AuditCycle, error) {
	row := q.db.QueryRow(ctx, updateAuditCycle,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var i AuditCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFramework = `-- name: UpdateFramework :one

UPDATE frameworks
SET name = $3, version = $4, description = $5, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, name, version, created_at, description, updated_at
`

type UpdateFrameworkParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Version        string
	Description    pgtype.Text
}

// ── Enhanced Frameworks ───────────────────────────────────────────────────
func (q *Queries) UpdateFramework(ctx context.Context, arg UpdateFrameworkParams) (Framework, error) {
	row := q.db.QueryRow(ctx, updateFramework,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.Version,
		arg.Description,
	)
	var i Framework
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Version,
		&i.CreatedAt,
		&i.Description,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAssessmentAnswer = `-- name: UpsertAssessmentAnswer :one

INSERT INTO assessment_answers (id, assessment_id, question_id, answer_text, answer_options)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (assessment_id, question_id) DO UPDATE
SET answer_text = EXCLUDED.answer_text,
    answer_options = EXCLUDED.answer_options,
    updated_at = NOW()
RETURNING id, assessment_id, question_id, answer_text, answer_options, created_at, updated_at
`

type UpsertAssessmentAnswerParams struct {
	ID            pgtype.UUID
	AssessmentID  pgtype.UUID
	QuestionID    pgtype.UUID
	AnswerText    pgtype.Text
	AnswerOptions []byte
}

// ── Assessment Answers ────────────────────────────────────────────────────
func (q *Queries) UpsertAssessmentAnswer(ctx context.Context, arg UpsertAssessmentAnswerParams) (AssessmentAnswer, error) {
	row := q.db.QueryRow(ctx, upsertAssessmentAnswer,
		arg.ID,
		arg.AssessmentID,
		arg.QuestionID,
		arg.AnswerText,
		arg.AnswerOptions,
	)
	var i AssessmentAnswer
	err := row.Scan(
		&i.ID,
		&i.AssessmentID,
		&i.QuestionID,
		&i.AnswerText,
		&i.AnswerOptions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
