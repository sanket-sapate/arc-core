// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trm.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDPADataScope = `-- name: AddDPADataScope :exec
INSERT INTO dpa_data_scope (dpa_id, dictionary_id, justification)
VALUES ($1, $2, $3)
ON CONFLICT (dpa_id, dictionary_id) DO UPDATE SET justification = EXCLUDED.justification
`

type AddDPADataScopeParams struct {
	DpaID         pgtype.UUID
	DictionaryID  pgtype.UUID
	Justification pgtype.Text
}

func (q *Queries) AddDPADataScope(ctx context.Context, arg AddDPADataScopeParams) error {
	_, err := q.db.Exec(ctx, addDPADataScope, arg.DpaID, arg.DictionaryID, arg.Justification)
	return err
}

const createAssessment = `-- name: CreateAssessment :one

INSERT INTO assessments (id, organization_id, vendor_id, framework_id, status, score)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at, audit_cycle_id
`

type CreateAssessmentParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	VendorID       pgtype.UUID
	FrameworkID    pgtype.UUID
	Status         pgtype.Text
	Score          pgtype.Int4
}

// ── Assessments ───────────────────────────────────────────────────────────
func (q *Queries) CreateAssessment(ctx context.Context, arg CreateAssessmentParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, createAssessment,
		arg.ID,
		arg.OrganizationID,
		arg.VendorID,
		arg.FrameworkID,
		arg.Status,
		arg.Score,
	)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VendorID,
		&i.FrameworkID,
		&i.Status,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuditCycleID,
	)
	return i, err
}

const createDPA = `-- name: CreateDPA :one

INSERT INTO dpas (id, organization_id, vendor_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, vendor_id, status, signed_at, created_at, updated_at
`

type CreateDPAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	VendorID       pgtype.UUID
	Status         string
}

// ── DPAs ──────────────────────────────────────────────────────────────────
func (q *Queries) CreateDPA(ctx context.Context, arg CreateDPAParams) (Dpa, error) {
	row := q.db.QueryRow(ctx, createDPA,
		arg.ID,
		arg.OrganizationID,
		arg.VendorID,
		arg.Status,
	)
	var i Dpa
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VendorID,
		&i.Status,
		&i.SignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFramework = `-- name: CreateFramework :one

INSERT INTO frameworks (id, organization_id, name, version)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, name, version, created_at, description, updated_at
`

type CreateFrameworkParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Version        string
}

// ── Frameworks ────────────────────────────────────────────────────────────
func (q *Queries) CreateFramework(ctx context.Context, arg CreateFrameworkParams) (Framework, error) {
	row := q.db.QueryRow(ctx, createFramework,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.Version,
	)
	var i Framework
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Version,
		&i.CreatedAt,
		&i.Description,
		&i.UpdatedAt,
	)
	return i, err
}

const createVendor = `-- name: CreateVendor :one

INSERT INTO vendors (id, organization_id, name, contact_email, compliance_status, risk_level)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at
`

type CreateVendorParams struct {
	ID               pgtype.UUID
	OrganizationID   pgtype.UUID
	Name             string
	ContactEmail     pgtype.Text
	ComplianceStatus pgtype.Text
	RiskLevel        pgtype.Text
}

// ── Vendors ───────────────────────────────────────────────────────────────
func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (Vendor, error) {
	row := q.db.QueryRow(ctx, createVendor,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.ContactEmail,
		arg.ComplianceStatus,
		arg.RiskLevel,
	)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.ContactEmail,
		&i.ComplianceStatus,
		&i.RiskLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReplicatedDictionary = `-- name: DeleteReplicatedDictionary :exec
DELETE FROM replicated_data_dictionary
WHERE id = $1
`

func (q *Queries) DeleteReplicatedDictionary(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteReplicatedDictionary, id)
	return err
}

const deleteVendor = `-- name: DeleteVendor :exec
DELETE FROM vendors
WHERE id = $1 AND organization_id = $2
`

type DeleteVendorParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) DeleteVendor(ctx context.Context, arg DeleteVendorParams) error {
	_, err := q.db.Exec(ctx, deleteVendor, arg.ID, arg.OrganizationID)
	return err
}

const getAssessment = `-- name: GetAssessment :one
SELECT id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at, audit_cycle_id FROM assessments
WHERE id = $1 AND organization_id = $2
`

type GetAssessmentParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetAssessment(ctx context.Context, arg GetAssessmentParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, getAssessment, arg.ID, arg.OrganizationID)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VendorID,
		&i.FrameworkID,
		&i.Status,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuditCycleID,
	)
	return i, err
}

const getDPA = `-- name: GetDPA :one
SELECT id, organization_id, vendor_id, status, signed_at, created_at, updated_at FROM dpas
WHERE id = $1 AND organization_id = $2
`

type GetDPAParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetDPA(ctx context.Context, arg GetDPAParams) (Dpa, error) {
	row := q.db.QueryRow(ctx, getDPA, arg.ID, arg.OrganizationID)
	var i Dpa
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VendorID,
		&i.Status,
		&i.SignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFramework = `-- name: GetFramework :one
SELECT id, organization_id, name, version, created_at, description, updated_at FROM frameworks
WHERE id = $1 AND organization_id = $2
`

type GetFrameworkParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetFramework(ctx context.Context, arg GetFrameworkParams) (Framework, error) {
	row := q.db.QueryRow(ctx, getFramework, arg.ID, arg.OrganizationID)
	var i Framework
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Version,
		&i.CreatedAt,
		&i.Description,
		&i.UpdatedAt,
	)
	return i, err
}

const getReplicatedDictionaryItem = `-- name: GetReplicatedDictionaryItem :one
SELECT id, organization_id, name, sensitivity, active, updated_at FROM replicated_data_dictionary
WHERE id = $1
`

func (q *Queries) GetReplicatedDictionaryItem(ctx context.Context, id pgtype.UUID) (ReplicatedDataDictionary, error) {
	row := q.db.QueryRow(ctx, getReplicatedDictionaryItem, id)
	var i ReplicatedDataDictionary
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Sensitivity,
		&i.Active,
		&i.UpdatedAt,
	)
	return i, err
}

const getVendor = `-- name: GetVendor :one
SELECT id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at FROM vendors
WHERE id = $1 AND organization_id = $2
`

type GetVendorParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) GetVendor(ctx context.Context, arg GetVendorParams) (Vendor, error) {
	row := q.db.QueryRow(ctx, getVendor, arg.ID, arg.OrganizationID)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.ContactEmail,
		&i.ComplianceStatus,
		&i.RiskLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertOutboxEvent = `-- name: InsertOutboxEvent :exec

INSERT INTO outbox_events (id, organization_id, aggregate_type, aggregate_id, event_type, payload)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) DO NOTHING
`

type InsertOutboxEventParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	AggregateType  string
	AggregateID    string
	EventType      string
	Payload        []byte
}

// ── Outbox ────────────────────────────────────────────────────────────────
func (q *Queries) InsertOutboxEvent(ctx context.Context, arg InsertOutboxEventParams) error {
	_, err := q.db.Exec(ctx, insertOutboxEvent,
		arg.ID,
		arg.OrganizationID,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
	)
	return err
}

const listAssessments = `-- name: ListAssessments :many
SELECT id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at, audit_cycle_id FROM assessments
WHERE organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAssessments(ctx context.Context, organizationID pgtype.UUID) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessments, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VendorID,
			&i.FrameworkID,
			&i.Status,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuditCycleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessmentsByVendor = `-- name: ListAssessmentsByVendor :many
SELECT id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at, audit_cycle_id FROM assessments
WHERE vendor_id = $1 AND organization_id = $2
ORDER BY created_at DESC
`

type ListAssessmentsByVendorParams struct {
	VendorID       pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) ListAssessmentsByVendor(ctx context.Context, arg ListAssessmentsByVendorParams) ([]Assessment, error) {
	rows, err := q.db.Query(ctx, listAssessmentsByVendor, arg.VendorID, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VendorID,
			&i.FrameworkID,
			&i.Status,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuditCycleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDPADataScope = `-- name: ListDPADataScope :many
SELECT d.dpa_id, d.dictionary_id, d.justification, r.name AS dict_name, r.sensitivity
FROM dpa_data_scope d
JOIN replicated_data_dictionary r ON r.id = d.dictionary_id
WHERE d.dpa_id = $1
`

type ListDPADataScopeRow struct {
	DpaID         pgtype.UUID
	DictionaryID  pgtype.UUID
	Justification pgtype.Text
	DictName      string
	Sensitivity   string
}

func (q *Queries) ListDPADataScope(ctx context.Context, dpaID pgtype.UUID) ([]ListDPADataScopeRow, error) {
	rows, err := q.db.Query(ctx, listDPADataScope, dpaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDPADataScopeRow
	for rows.Next() {
		var i ListDPADataScopeRow
		if err := rows.Scan(
			&i.DpaID,
			&i.DictionaryID,
			&i.Justification,
			&i.DictName,
			&i.Sensitivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDPAsByVendor = `-- name: ListDPAsByVendor :many
SELECT id, organization_id, vendor_id, status, signed_at, created_at, updated_at FROM dpas
WHERE vendor_id = $1 AND organization_id = $2
ORDER BY created_at DESC
`

type ListDPAsByVendorParams struct {
	VendorID       pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) ListDPAsByVendor(ctx context.Context, arg ListDPAsByVendorParams) ([]Dpa, error) {
	rows, err := q.db.Query(ctx, listDPAsByVendor, arg.VendorID, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dpa
	for rows.Next() {
		var i Dpa
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VendorID,
			&i.Status,
			&i.SignedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFrameworks = `-- name: ListFrameworks :many
SELECT id, organization_id, name, version, created_at, description, updated_at FROM frameworks
WHERE organization_id = $1
ORDER BY name ASC
`

func (q *Queries) ListFrameworks(ctx context.Context, organizationID pgtype.UUID) ([]Framework, error) {
	rows, err := q.db.Query(ctx, listFrameworks, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Framework
	for rows.Next() {
		var i Framework
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.Version,
			&i.CreatedAt,
			&i.Description,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReplicatedDictionary = `-- name: ListReplicatedDictionary :many
SELECT id, organization_id, name, sensitivity, active, updated_at FROM replicated_data_dictionary
WHERE organization_id = $1 AND active = true
ORDER BY name ASC
`

func (q *Queries) ListReplicatedDictionary(ctx context.Context, organizationID pgtype.UUID) ([]ReplicatedDataDictionary, error) {
	rows, err := q.db.Query(ctx, listReplicatedDictionary, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReplicatedDataDictionary
	for rows.Next() {
		var i ReplicatedDataDictionary
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.Sensitivity,
			&i.Active,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVendors = `-- name: ListVendors :many
SELECT id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at FROM vendors
WHERE organization_id = $1
ORDER BY name ASC
`

func (q *Queries) ListVendors(ctx context.Context, organizationID pgtype.UUID) ([]Vendor, error) {
	rows, err := q.db.Query(ctx, listVendors, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vendor
	for rows.Next() {
		var i Vendor
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.ContactEmail,
			&i.ComplianceStatus,
			&i.RiskLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssessmentStatus = `-- name: UpdateAssessmentStatus :one
UPDATE assessments
SET status = $3, score = $4, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vendor_id, framework_id, status, score, created_at, updated_at, audit_cycle_id
`

type UpdateAssessmentStatusParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Status         pgtype.Text
	Score          pgtype.Int4
}

func (q *Queries) UpdateAssessmentStatus(ctx context.Context, arg UpdateAssessmentStatusParams) (Assessment, error) {
	row := q.db.QueryRow(ctx, updateAssessmentStatus,
		arg.ID,
		arg.OrganizationID,
		arg.Status,
		arg.Score,
	)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VendorID,
		&i.FrameworkID,
		&i.Status,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuditCycleID,
	)
	return i, err
}

const updateDPAStatus = `-- name: UpdateDPAStatus :one
UPDATE dpas
SET status = $3, signed_at = $4, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vendor_id, status, signed_at, created_at, updated_at
`

type UpdateDPAStatusParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Status         string
	SignedAt       pgtype.Timestamptz
}

func (q *Queries) UpdateDPAStatus(ctx context.Context, arg UpdateDPAStatusParams) (Dpa, error) {
	row := q.db.QueryRow(ctx, updateDPAStatus,
		arg.ID,
		arg.OrganizationID,
		arg.Status,
		arg.SignedAt,
	)
	var i Dpa
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VendorID,
		&i.Status,
		&i.SignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVendor = `-- name: UpdateVendor :one
UPDATE vendors
SET name = $3, contact_email = $4, compliance_status = $5, risk_level = $6, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, name, contact_email, compliance_status, risk_level, created_at, updated_at
`

type UpdateVendorParams struct {
	ID               pgtype.UUID
	OrganizationID   pgtype.UUID
	Name             string
	ContactEmail     pgtype.Text
	ComplianceStatus pgtype.Text
	RiskLevel        pgtype.Text
}

func (q *Queries) UpdateVendor(ctx context.Context, arg UpdateVendorParams) (Vendor, error) {
	row := q.db.QueryRow(ctx, updateVendor,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.ContactEmail,
		arg.ComplianceStatus,
		arg.RiskLevel,
	)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.ContactEmail,
		&i.ComplianceStatus,
		&i.RiskLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertReplicatedDictionary = `-- name: UpsertReplicatedDictionary :exec

INSERT INTO replicated_data_dictionary (id, organization_id, name, sensitivity, active, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name,
    sensitivity = EXCLUDED.sensitivity,
    active = EXCLUDED.active,
    updated_at = EXCLUDED.updated_at
`

type UpsertReplicatedDictionaryParams struct {
	ID             pgtype.UUID
	OrganizationID pgtype.UUID
	Name           string
	Sensitivity    string
	Active         bool
	UpdatedAt      pgtype.Timestamptz
}

// ── Replicated Data Dictionary ────────────────────────────────────────────
func (q *Queries) UpsertReplicatedDictionary(ctx context.Context, arg UpsertReplicatedDictionaryParams) error {
	_, err := q.db.Exec(ctx, upsertReplicatedDictionary,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.Sensitivity,
		arg.Active,
		arg.UpdatedAt,
	)
	return err
}
