// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignUserRole = `-- name: AssignUserRole :exec
INSERT INTO user_organization_roles (user_id, organization_id, role_id)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, organization_id, role_id) DO NOTHING
`

type AssignUserRoleParams struct {
	UserID         pgtype.UUID
	OrganizationID pgtype.UUID
	RoleID         pgtype.UUID
}

func (q *Queries) AssignUserRole(ctx context.Context, arg AssignUserRoleParams) error {
	_, err := q.db.Exec(ctx, assignUserRole, arg.UserID, arg.OrganizationID, arg.RoleID)
	return err
}

const getDefaultRole = `-- name: GetDefaultRole :one
SELECT id, organization_id, name, description, created_at FROM roles
WHERE organization_id = $1 AND name = 'member'
`

func (q *Queries) GetDefaultRole(ctx context.Context, organizationID pgtype.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, getDefaultRole, organizationID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getOrganizationByName = `-- name: GetOrganizationByName :one
SELECT id, name, created_at FROM organizations
WHERE name = $1
`

func (q *Queries) GetOrganizationByName(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationByName, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (id, email)
VALUES ($1, $2)
ON CONFLICT (id) DO UPDATE SET email = EXCLUDED.email
RETURNING id, email, created_at
`

type UpsertUserParams struct {
	ID    pgtype.UUID
	Email string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser, arg.ID, arg.Email)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.CreatedAt)
	return i, err
}
