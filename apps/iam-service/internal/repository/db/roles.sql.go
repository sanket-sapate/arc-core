// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRole = `-- name: CreateRole :one
INSERT INTO roles (organization_id, name, description)
VALUES ($1, $2, $3)
RETURNING id, name, description, created_at
`

type CreateRoleParams struct {
	OrganizationID pgtype.UUID
	Name           string
	Description    string
}

type CreateRoleRow struct {
	ID          pgtype.UUID
	Name        string
	Description string
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (CreateRoleRow, error) {
	row := q.db.QueryRow(ctx, createRole, arg.OrganizationID, arg.Name, arg.Description)
	var i CreateRoleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRolePermissions = `-- name: DeleteRolePermissions :exec
DELETE FROM role_permissions
WHERE role_id = $1
`

func (q *Queries) DeleteRolePermissions(ctx context.Context, roleID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRolePermissions, roleID)
	return err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT permission_slug
FROM role_permissions
WHERE role_id = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var permission_slug string
		if err := rows.Scan(&permission_slug); err != nil {
			return nil, err
		}
		items = append(items, permission_slug)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRolePermission = `-- name: InsertRolePermission :exec
INSERT INTO role_permissions (role_id, permission_slug)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type InsertRolePermissionParams struct {
	RoleID         pgtype.UUID
	PermissionSlug string
}

func (q *Queries) InsertRolePermission(ctx context.Context, arg InsertRolePermissionParams) error {
	_, err := q.db.Exec(ctx, insertRolePermission, arg.RoleID, arg.PermissionSlug)
	return err
}

const listRolesForOrganization = `-- name: ListRolesForOrganization :many
SELECT id, name, created_at
FROM roles
WHERE organization_id = $1
ORDER BY name
`

type ListRolesForOrganizationRow struct {
	ID        pgtype.UUID
	Name      string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) ListRolesForOrganization(ctx context.Context, organizationID pgtype.UUID) ([]ListRolesForOrganizationRow, error) {
	rows, err := q.db.Query(ctx, listRolesForOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolesForOrganizationRow
	for rows.Next() {
		var i ListRolesForOrganizationRow
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET name = $2, description = $3
WHERE id = $1 AND organization_id = $4
RETURNING id, name, description, created_at
`

type UpdateRoleParams struct {
	ID             pgtype.UUID
	Name           string
	Description    string
	OrganizationID pgtype.UUID
}

type UpdateRoleRow struct {
	ID          pgtype.UUID
	Name        string
	Description string
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (UpdateRoleRow, error) {
	row := q.db.QueryRow(ctx, updateRole,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.OrganizationID,
	)
	var i UpdateRoleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
