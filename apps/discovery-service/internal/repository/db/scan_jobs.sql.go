// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scan_jobs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createScanJob = `-- name: CreateScanJob :one
INSERT INTO scan_jobs (id, organization_id, third_party_job_id, source_name, status, findings_synced)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, third_party_job_id, source_name, status, findings_synced, created_at, updated_at
`

type CreateScanJobParams struct {
	ID              pgtype.UUID `json:"id"`
	OrganizationID  pgtype.UUID `json:"organization_id"`
	ThirdPartyJobID string      `json:"third_party_job_id"`
	SourceName      string      `json:"source_name"`
	Status          pgtype.Text `json:"status"`
	FindingsSynced  pgtype.Bool `json:"findings_synced"`
}

func (q *Queries) CreateScanJob(ctx context.Context, arg CreateScanJobParams) (ScanJob, error) {
	row := q.db.QueryRow(ctx, createScanJob,
		arg.ID,
		arg.OrganizationID,
		arg.ThirdPartyJobID,
		arg.SourceName,
		arg.Status,
		arg.FindingsSynced,
	)
	var i ScanJob
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ThirdPartyJobID,
		&i.SourceName,
		&i.Status,
		&i.FindingsSynced,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScanJob = `-- name: GetScanJob :one
SELECT id, organization_id, third_party_job_id, source_name, status, findings_synced, created_at, updated_at FROM scan_jobs
WHERE id = $1 AND organization_id = $2
`

type GetScanJobParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) GetScanJob(ctx context.Context, arg GetScanJobParams) (ScanJob, error) {
	row := q.db.QueryRow(ctx, getScanJob, arg.ID, arg.OrganizationID)
	var i ScanJob
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ThirdPartyJobID,
		&i.SourceName,
		&i.Status,
		&i.FindingsSynced,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPendingScanJobs = `-- name: ListPendingScanJobs :many
SELECT id, organization_id, third_party_job_id, source_name, status, findings_synced, created_at, updated_at FROM scan_jobs
WHERE status IN ('PENDING', 'RUNNING')
ORDER BY created_at ASC
`

func (q *Queries) ListPendingScanJobs(ctx context.Context) ([]ScanJob, error) {
	rows, err := q.db.Query(ctx, listPendingScanJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScanJob
	for rows.Next() {
		var i ScanJob
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ThirdPartyJobID,
			&i.SourceName,
			&i.Status,
			&i.FindingsSynced,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markScanJobSynced = `-- name: MarkScanJobSynced :exec
UPDATE scan_jobs
SET findings_synced = true, status = 'COMPLETED', updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkScanJobSynced(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markScanJobSynced, id)
	return err
}

const updateScanJobStatus = `-- name: UpdateScanJobStatus :one
UPDATE scan_jobs
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, organization_id, third_party_job_id, source_name, status, findings_synced, created_at, updated_at
`

type UpdateScanJobStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateScanJobStatus(ctx context.Context, arg UpdateScanJobStatusParams) (ScanJob, error) {
	row := q.db.QueryRow(ctx, updateScanJobStatus, arg.ID, arg.Status)
	var i ScanJob
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ThirdPartyJobID,
		&i.SourceName,
		&i.Status,
		&i.FindingsSynced,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
